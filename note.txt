* passphase = salt_hash(passwd)

can get full path of upload file so just save .sign in UPLOADER_FOLDER

TASK 1:
	salt = random(32 byte)
	hash_pass = hash(passwd + salt)

	storage: passphase = salt + hash_pass

	get hash_pass and salt: 
		salt = passphase[:32]  (because salt length is 32)
		hash_pass = passphase[32:]
		
	ref: 
		- https://nitratine.net/blog/post/how-to-hash-passwords-in-python/
		- https://medium.com/@pYdeas/the-point-of-salting-and-hashing-passwords-demonstrated-with-python-4879a156d99a

---------------------------------------

TASK 2:
	gen RSA_PubKey_PEM and RSA_PriKey_PEM (RSA) (length 2048) 
	
	RSA_PriKey_PEM -> encode(AES)
		- AES_PriKey(passphase)
		
	storage: 
		- RSA_PriKey_PEM.encode(AES_PubKey())
		- RSA_PubKey_PEM.encode("utf-8")
		
	ref: 
		- AES: https://blog.boot.dev/cryptography/aes-256-cipher-python-cryptography-examples/
		- RSA: https://cryptobook.nakov.com/asymmetric-key-ciphers/rsa-encrypt-decrypt-examples
		- RSA: https://stackoverflow.com/questions/30056762/rsa-encryption-and-decryption-in-python
		- RSA: https://stackoverflow.com/questions/70841986/how-to-add-a-custom-rsa-key-pair-to-a-pem-file
		
---------------------------------------

AUTHEN and AUTHOR
	- Use session to authorize
	- If autheN success then write user info into session
	- If logout -> clear user session

---------------------------------------

TASK 3:	
	- Create new passhase from new password
	- Decode RSA_PriKey_PEM to get original RSA_PriKey_PEM
	- Encode RSA_PriKey_PEM with new passhase

	storage:
		- new RSA_PriKey_PEM
		- new passhase
		
		
Task 6 + 7: (Digital signature)
	- Digital signature: ensure data is Integrity and Authenticity
	- Read file as binary
	- sign:
		+ hash_file = hash256(file)
		+ signature = hash_file^d mod n (from private key)
	- verify:
		+ hash_file = hash256(file)
		+ hash_from_sign = signature^e mod n (from public key)
		-> hash_file == hash_from_sign ? true : false
			
	
	ref: https://cryptobook.nakov.com/digital-signatures/rsa-sign-verify-examples


